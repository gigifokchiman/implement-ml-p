#!/bin/bash
# Terraform Version Configuration Generator
# Generates terraform blocks from centralized YAML configuration
# Industry standard approach used by Netflix, Airbnb, Spotify

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TERRAFORM_DIR="$SCRIPT_DIR/../terraform"
VERSION_CONFIG="$TERRAFORM_DIR/versions/terraform-versions.yaml"
ENVIRONMENTS_DIR="$TERRAFORM_DIR/environments"

# Colors
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

# Check if yq is available
check_dependencies() {
    if ! command -v yq >/dev/null 2>&1; then
        print_warning "yq not found. Installing via brew..."
        if command -v brew >/dev/null 2>&1; then
            brew install yq
        else
            echo "Please install yq: https://github.com/mikefarah/yq"
            exit 1
        fi
    fi
}

# Generate version constraint based on strategy
generate_version_constraint() {
    local provider="$1"
    local environment="$2"
    local base_version="$3"
    
    local strategy_type
    strategy_type=$(yq eval ".strategies.${environment}.type" "$VERSION_CONFIG")
    
    local pattern
    pattern=$(yq eval ".strategies.${environment}.pattern" "$VERSION_CONFIG")
    
    local security_critical
    security_critical=$(yq eval ".security_critical[] | select(. == \"$provider\")" "$VERSION_CONFIG" | wc -l)
    
    # Security critical providers always use exact versions
    if [[ $security_critical -gt 0 ]] || [[ "$strategy_type" == "exact_version" ]]; then
        echo "= $base_version"
    elif [[ "$strategy_type" == "minor_updates" ]]; then
        echo "~> ${base_version%.*}"  # Remove patch version
    elif [[ "$strategy_type" == "patch_updates" ]]; then
        echo "~> ${base_version%.*}.0"  # Pin to patch series
    else
        echo "= $base_version"  # Default to exact
    fi
}

# Generate terraform block for environment
generate_terraform_block() {
    local environment="$1"
    local output_file="$2"
    
    local terraform_version
    terraform_version=$(yq eval '.terraform_version' "$VERSION_CONFIG")
    
    cat > "$output_file" << EOF
# Generated terraform configuration for $environment environment
# DO NOT EDIT MANUALLY - Generated by generate-terraform-versions.sh
# Source: terraform/versions/terraform-versions.yaml

terraform {
  required_version = "$terraform_version"

  required_providers {
EOF

    # Add core providers
    local providers
    providers=$(yq eval '.provider_versions | keys | .[]' "$VERSION_CONFIG")
    
    while IFS= read -r provider; do
        local base_version
        base_version=$(yq eval ".provider_versions.${provider}" "$VERSION_CONFIG")
        
        local version_constraint
        version_constraint=$(generate_version_constraint "$provider" "$environment" "$base_version")
        
        cat >> "$output_file" << EOF
    $provider = {
      source  = "hashicorp/$provider"
      version = "$version_constraint"
    }
EOF
    done <<< "$providers"

    # Add local dev providers for local environment
    if [[ "$environment" == "local" ]]; then
        cat >> "$output_file" << EOF
    # Local development providers
    kind = {
      source  = "kind.local/gigifokchiman/kind"
      version = "= $(yq eval '.local_dev_providers.kind' "$VERSION_CONFIG")"
    }
    docker = {
      source  = "kreuzwerker/docker"
      version = "= $(yq eval '.local_dev_providers.docker' "$VERSION_CONFIG")"
    }
EOF
    fi

    cat >> "$output_file" << EOF
  }

  # Uncomment for remote state
  # backend "s3" {
  #   bucket = "your-terraform-state-bucket"
  #   key    = "$environment/terraform.tfstate"
  #   region = "us-west-2"
  # }
}
EOF
}

# Generate versions.tf for all environments
generate_all_environments() {
    print_info "Generating terraform version configurations..."
    
    for env_dir in "$ENVIRONMENTS_DIR"/*; do
        if [[ -d "$env_dir" && -f "$env_dir/main.tf" ]]; then
            local env_name
            env_name=$(basename "$env_dir")
            
            local versions_file="$env_dir/versions.tf"
            
            print_info "Generating $env_name environment versions..."
            generate_terraform_block "$env_name" "$versions_file"
            
            print_success "Generated: $versions_file"
        fi
    done
}

# Update existing main.tf files to remove terraform blocks
update_main_tf_files() {
    print_info "Updating main.tf files to remove terraform blocks..."
    
    for env_dir in "$ENVIRONMENTS_DIR"/*; do
        if [[ -d "$env_dir" && -f "$env_dir/main.tf" ]]; then
            local env_name
            env_name=$(basename "$env_dir")
            local main_tf="$env_dir/main.tf"
            
            # Create backup
            cp "$main_tf" "$main_tf.backup"
            
            # Remove terraform block and module provider_versions
            # This is a simplified approach - in practice you'd use more sophisticated parsing
            sed -i.bak '/^# Provider version management/,/^terraform {/d' "$main_tf"
            sed -i.bak '/^terraform {/,/^}/d' "$main_tf"
            sed -i.bak '/^module "provider_versions"/,/^}/d' "$main_tf"
            
            # Clean up empty lines
            sed -i.bak '/^$/N;/^\n$/d' "$main_tf"
            
            # Remove backup file
            rm -f "$main_tf.bak"
            
            print_success "Updated: $main_tf"
        fi
    done
}

# Show version summary
show_version_summary() {
    print_info "Provider Version Summary:"
    echo ""
    
    echo "Environment Strategies:"
    for env in local dev staging prod; do
        local strategy
        strategy=$(yq eval ".strategies.${env}.type" "$VERSION_CONFIG" 2>/dev/null || echo "not_defined")
        echo "  $env: $strategy"
    done
    
    echo ""
    echo "Core Provider Versions:"
    yq eval '.provider_versions | to_entries | .[] | "  " + .key + ": " + .value' "$VERSION_CONFIG"
    
    echo ""
    echo "Security Critical Providers:"
    yq eval '.security_critical[] | "  - " + .' "$VERSION_CONFIG"
}

# Validate generated configurations
validate_configurations() {
    print_info "Validating generated configurations..."
    
    for env_dir in "$ENVIRONMENTS_DIR"/*; do
        if [[ -d "$env_dir" && -f "$env_dir/versions.tf" ]]; then
            local env_name
            env_name=$(basename "$env_dir")
            
            print_info "Validating $env_name..."
            
            cd "$env_dir"
            if terraform validate > /dev/null 2>&1; then
                print_success "$env_name configuration is valid"
            else
                print_warning "$env_name configuration has issues"
            fi
        fi
    done
}

# Main execution
main() {
    local command="${1:-generate}"
    
    case "$command" in
        generate)
            check_dependencies
            generate_all_environments
            update_main_tf_files
            show_version_summary
            validate_configurations
            ;;
        summary)
            show_version_summary
            ;;
        validate)
            validate_configurations
            ;;
        *)
            echo "Usage: $0 [generate|summary|validate]"
            echo ""
            echo "Commands:"
            echo "  generate  Generate terraform version configurations for all environments"
            echo "  summary   Show version configuration summary"
            echo "  validate  Validate generated configurations"
            ;;
    esac
}

main "$@"